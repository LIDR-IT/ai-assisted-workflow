#!/bin/bash
# Platform adapter: GitHub Copilot (VSCode)
# Rules: copy-flatten .instructions.md + index | Skills: symlink
# Commands: copy .prompt.md | Agents: copy .agent.md | MCP: .vscode/mcp.json
# Hooks: hooks.json + scripts symlink

COPILOT_DIR="$PROJECT_ROOT/.github"
COPILOT_MCP_DIR="$PROJECT_ROOT/.vscode"

copilot_rules() {
  log_verbose "Copilot rules: copy-flatten to .instructions.md + index"

  if run_or_dry "copy all .md files to .github/rules/ (.instructions.md) + generate index"; then
    return 0
  fi

  # Preserve .github/ but recreate rules/ subdirectory
  [ -e "$COPILOT_DIR/rules" ] || [ -L "$COPILOT_DIR/rules" ] && rm -rf "$COPILOT_DIR/rules"
  mkdir -p "$COPILOT_DIR/rules"

  local count=0
  while IFS= read -r -d '' rule_file; do
    local rule_name
    rule_name=$(basename "$rule_file")
    local rule_base="${rule_name%.md}"
    local dest_file="$COPILOT_DIR/rules/${rule_base}.instructions.md"
    local subdir
    subdir=$(dirname "$rule_file" | sed "s|$AGENTS_DIR/rules||" | sed 's|^/||')

    # Transform frontmatter for Copilot compatibility
    if has_frontmatter "$rule_file"; then
      local body
      body=$(extract_body "$rule_file")
      local description
      description=$(extract_field "$rule_file" "description")
      local globs
      globs=$(extract_field "$rule_file" "globs")

      {
        echo "---"
        [ -n "$description" ] && echo "description: $description"
        if [ -n "$globs" ]; then
          local apply_to
          apply_to=$(echo "$globs" | sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | sed 's/,\s*/, /g')
          echo "applyTo: \"$apply_to\""
        fi
        echo "---"
        echo "$body"
      } > "$dest_file"
    else
      cp "$rule_file" "$dest_file"
    fi

    touch "$dest_file"

    if [ -n "$subdir" ]; then
      log_detail "${rule_base}.instructions.md (from $subdir/${rule_name})"
    else
      log_detail "${rule_base}.instructions.md (from ${rule_name})"
    fi
    ((count++))
  done < <(find "$AGENTS_DIR/rules" -type f -name "*.md" ! -name "sync-*.sh" ! -name "README.md" -print0)

  if [ $count -gt 0 ]; then
    log_info "Copied $count rules to .instructions.md format"
  else
    log_warn "No rules found to copy"
  fi

  # Generate copilot-instructions.md index
  _copilot_generate_instructions_index
}

_copilot_generate_instructions_index() {
  local timestamp
  timestamp=$(date "+%Y-%m-%d %H:%M:%S")

  cat > "$COPILOT_DIR/copilot-instructions.md" << COPILOT_INDEX
# Copilot Instructions

> **Auto-generated by sync.sh** — Do not edit manually.
> Last synchronized: $timestamp

This project uses a centralized source-of-truth pattern. All rules are in \`.agents/rules/\`.

## Project Rules

Individual rules are in \`.github/rules/*.instructions.md\`. Below is a summary by category.

### Code Standards

- **[Principles](rules/principles.instructions.md)** — Core principles and architectural decisions
- **[Style](rules/style.instructions.md)** — Code style guidelines and formatting standards

### Content Guidelines

- **[Copywriting](rules/copywriting.instructions.md)** — Copywriting and content standards

### Design Standards

- **[Web Design](rules/web-design.instructions.md)** — Web interface guidelines and accessibility

### Framework-Specific

- **[React Native](rules/react-native.instructions.md)** — React Native best practices

### Process & Workflow

- **[Git Workflow](rules/git-workflow.instructions.md)** — Git branching, commits, and PRs
- **[Documentation](rules/documentation.instructions.md)** — Documentation standards

### Quality Assurance

- **[Testing](rules/testing.instructions.md)** — Testing philosophy and checklists
- **[Testing Scripts](rules/testing-scripts.instructions.md)** — Bash script testing patterns

### Team Conventions

- **[Skills Management](rules/skills-management.instructions.md)** — AI agent skills guidelines
- **[Third-Party Security](rules/third-party-security.instructions.md)** — Security for dependencies

### Tools & Extensions

- **[Claude Code Extensions](rules/claude-code-extensions.instructions.md)** — Claude Code extension reference
- **[Use Context7](rules/use-context7.instructions.md)** — Context7 MCP usage guidelines

## Useful Commands

\`\`\`bash
# Sync all configurations
./.agents/sync.sh

# Format code
npm run format

# Build docs
npm run docs:build
\`\`\`

## Cross-Compatibility

Copilot also reads from \`CLAUDE.md\` and \`AGENTS.md\` in the project root.
Rules are also available via \`.claude/rules/\` (symlink to \`.agents/rules/\`).
COPILOT_INDEX

  log_info "Generated .github/copilot-instructions.md"
}

copilot_skills() {
  create_symlink "../.agents/skills" "$COPILOT_DIR/skills" "skills"
}

copilot_commands() {
  log_verbose "Copilot commands: copy-rename to .prompt.md"

  if run_or_dry "convert and copy commands to .github/prompts/"; then
    return 0
  fi

  # Preserve .github/ but recreate prompts/ subdirectory
  [ -e "$COPILOT_DIR/prompts" ] || [ -L "$COPILOT_DIR/prompts" ] && rm -rf "$COPILOT_DIR/prompts"
  mkdir -p "$COPILOT_DIR/prompts"

  local count=0
  for md_file in "$AGENTS_DIR/commands"/*.md; do
    [ -f "$md_file" ] || continue
    local base_name
    base_name=$(basename "$md_file" .md)

    # Skip sync scripts and READMEs
    case "$base_name" in
      sync-*|README|readme) continue ;;
    esac

    local prompt_file="$COPILOT_DIR/prompts/${base_name}.prompt.md"
    _copilot_convert_to_prompt "$md_file" "$prompt_file"
    log_detail "${base_name}.md → ${base_name}.prompt.md"
    ((count++))
  done

  if [ $count -gt 0 ]; then
    log_info "Converted $count commands to .prompt.md format"
  else
    log_warn "No commands found to convert"
  fi
}

_copilot_convert_to_prompt() {
  local md_file=$1 prompt_file=$2

  local description=""
  if has_frontmatter "$md_file"; then
    description=$(extract_field "$md_file" "description")
  fi

  local prompt
  prompt=$(extract_body "$md_file")
  # Convert $ARGUMENTS to Copilot-compatible reference
  prompt=$(echo "$prompt" | sed 's/\$ARGUMENTS/{{{ input }}}/g')

  {
    echo "---"
    [ -n "$description" ] && echo "description: $description"
    echo "mode: agent"
    echo "---"
    echo "$prompt"
  } > "$prompt_file"
}

copilot_agents() {
  log_verbose "Copilot agents: copy-rename to .agent.md"

  if run_or_dry "convert and copy agents to .github/agents/"; then
    return 0
  fi

  # Preserve .github/ but recreate agents/ subdirectory
  [ -e "$COPILOT_DIR/agents" ] || [ -L "$COPILOT_DIR/agents" ] && rm -rf "$COPILOT_DIR/agents"
  mkdir -p "$COPILOT_DIR/agents"

  local count=0
  for md_file in "$AGENTS_DIR/subagents"/*.md; do
    [ -f "$md_file" ] || continue
    local base_name
    base_name=$(basename "$md_file" .md)
    local agent_file="$COPILOT_DIR/agents/${base_name}.agent.md"

    _copilot_convert_to_agent "$md_file" "$agent_file"
    log_detail "${base_name}.md → ${base_name}.agent.md"
    ((count++))
  done

  if [ $count -gt 0 ]; then
    log_info "Converted $count agents to .agent.md format"
  else
    log_warn "No agents found to convert"
  fi
}

_copilot_convert_to_agent() {
  local md_file=$1 agent_file=$2

  local name="" description=""
  if has_frontmatter "$md_file"; then
    name=$(extract_field "$md_file" "name")
    description=$(extract_field "$md_file" "description")
  fi

  local body
  body=$(extract_body "$md_file")

  {
    echo "---"
    [ -n "$name" ] && echo "name: $name"
    [ -n "$description" ] && echo "description: \"$description\""
    echo "tools:"
    echo "  - codebase"
    echo "  - editFiles"
    echo "  - terminalLastCommand"
    echo "---"
    echo "$body"
  } > "$agent_file"
}

copilot_mcp() {
  log_verbose "Copilot MCP: generate .vscode/mcp.json"
  mkdir -p "$COPILOT_MCP_DIR"

  # VSCode uses "servers" (not "mcpServers") and ${env:VAR} syntax
  jq '{
    servers: (
      .servers |
      to_entries |
      map(
        select(.value.platforms | index("copilot")) |
        {
          key: .key,
          value: (
            .value |
            del(.platforms, .description) |
            if .type == "http" then
              { url: .url, headers: (.headers // {}) }
            else
              {
                command: .command,
                args: (.args // []),
                env: (
                  .env // {} |
                  to_entries |
                  map({key: .key, value: .value}) |
                  from_entries
                )
              }
            end
          )
        }
      ) |
      from_entries
    )
  }' "$AGENTS_DIR/mcp/mcp-servers.json" > "$COPILOT_MCP_DIR/mcp.json"

  log_info "Generated .vscode/mcp.json"
}

copilot_hooks() {
  log_verbose "Copilot hooks: scripts symlink + hooks.json"

  mkdir -p "$COPILOT_DIR/hooks"

  # Create hooks scripts symlink
  create_symlink "../../.agents/hooks/scripts" "$COPILOT_DIR/hooks/scripts" "hooks scripts"

  local source_file="$AGENTS_DIR/hooks/hooks.json"

  # Check if any hooks target copilot
  local copilot_hooks_count
  copilot_hooks_count=$(jq '[.hooks | to_entries[] | select(.value.platforms | index("copilot"))] | length' "$source_file")

  local copilot_hooks_json
  if [ "$copilot_hooks_count" -eq 0 ]; then
    copilot_hooks_json='{
  "version": 1,
  "_note": "No hooks configured for Copilot",
  "hooks": {}
}'
  else
    copilot_hooks_json=$(jq '{
      version: 1,
      hooks: {
        preToolUse: [
          (
            .hooks | to_entries | map(
              select(.value.platforms | index("copilot")) |
              select(.value.event == "PreToolUse") |
              {
                matcher: .value.matcher,
                command: ("bash .github/hooks/scripts/" + .key + ".sh"),
                timeout: .value.timeout
              }
            )
          )[]
        ],
        postToolUse: [
          (
            .hooks | to_entries | map(
              select(.value.platforms | index("copilot")) |
              select(.value.event == "PostToolUse") |
              {
                matcher: .value.matcher,
                command: ("bash .github/hooks/scripts/" + .key + ".sh"),
                timeout: .value.timeout
              }
            )
          )[]
        ]
      }
    } | .hooks |= with_entries(select(.value | length > 0))' "$source_file")
  fi

  echo "$copilot_hooks_json" > "$COPILOT_DIR/hooks/hooks.json"

  local hook_count
  hook_count=$(echo "$copilot_hooks_json" | jq '.hooks | to_entries | length' 2>/dev/null || echo "0")

  if [ "$hook_count" -gt 0 ]; then
    log_info "Updated .github/hooks/hooks.json ($hook_count hook types)"
  else
    log_info "Updated .github/hooks/hooks.json (empty)"
  fi
}

copilot_verify() {
  local errors=0

  # Rules (copied files)
  if [ -d "$COPILOT_DIR/rules" ]; then
    local count
    count=$(find "$COPILOT_DIR/rules" -type f -name "*.instructions.md" 2>/dev/null | wc -l | tr -d ' ')
    log_info "copilot rules: $count .instructions.md files"
  else
    log_error "copilot rules: Directory not found"
    ((errors++))
  fi

  # Instructions index
  if [ -f "$COPILOT_DIR/copilot-instructions.md" ]; then
    log_info "copilot: copilot-instructions.md index"
  else
    log_error "copilot: copilot-instructions.md not found"
    ((errors++))
  fi

  # Skills symlink
  if [ -L "$COPILOT_DIR/skills" ]; then
    log_info "copilot skills: $COPILOT_DIR/skills → $(readlink "$COPILOT_DIR/skills")"
  else
    log_error "copilot skills: Not a symlink"
    ((errors++))
  fi

  # Prompts
  if [ -d "$COPILOT_DIR/prompts" ]; then
    local prompt_count
    prompt_count=$(find "$COPILOT_DIR/prompts" -name "*.prompt.md" 2>/dev/null | wc -l | tr -d ' ')
    log_info "copilot prompts: $prompt_count .prompt.md files"
  else
    log_error "copilot prompts: Directory not found"
    ((errors++))
  fi

  # Agents
  if [ -d "$COPILOT_DIR/agents" ]; then
    local agent_count
    agent_count=$(find "$COPILOT_DIR/agents" -name "*.agent.md" 2>/dev/null | wc -l | tr -d ' ')
    log_info "copilot agents: $agent_count .agent.md files"
  else
    log_error "copilot agents: Directory not found"
    ((errors++))
  fi

  # MCP config
  if [ -f "$COPILOT_MCP_DIR/mcp.json" ]; then
    log_info "copilot MCP: .vscode/mcp.json"
  else
    log_error "copilot MCP: .vscode/mcp.json not found"
    ((errors++))
  fi

  # Hooks scripts symlink
  if [ -L "$COPILOT_DIR/hooks/scripts" ]; then
    log_info "copilot hooks: scripts symlink OK"
  else
    log_error "copilot hooks: Missing scripts symlink"
    ((errors++))
  fi

  # Hooks config
  if [ -f "$COPILOT_DIR/hooks/hooks.json" ]; then
    local hook_count
    hook_count=$(jq '.hooks | to_entries | length' "$COPILOT_DIR/hooks/hooks.json" 2>/dev/null || echo "0")
    log_info "copilot hooks.json: $hook_count hook types"
  else
    log_warn "copilot hooks: No .github/hooks/hooks.json"
  fi

  return $errors
}
